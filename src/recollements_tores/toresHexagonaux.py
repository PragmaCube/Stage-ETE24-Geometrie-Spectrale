import numpy as np
from scipy.optimize import minimize

import os
import random

###########################################################
# Nombre de valeurs propres à calculer
nbrVP = 10

# Nombre de divisions par côté
precision = 45

signeBords = [""] * 36

# Nom du fichier .edp
nom = "tore_hex"

# Chemin du fichier .edp
chemin = "path"

# Chemin de l'exécutable modifié, si besoin, de FreeFem++
cheminFF = "path"

# Chemin du fichier de sauvegarde des données
sauvegarde = "path"

v11 = 1 + 2 * np.cos(np.pi / 7) - np.sin(np.pi / 14)
v12 = np.cos(np.pi / 14)

def reflection(coordX, coordY, centreX, centreY):
    coord = [0, 0]

    coord[0] = np.cos(np.pi) * (coordX - centreX) - np.sin(np.pi) * (coordY - centreY) + centreX
    coord[1] = np.cos(np.pi) * (coordY - centreY) + np.sin(np.pi) * (coordX - centreX) + centreY

    return coord

def valeurPropre(params):
    bugDeSigne = 0

    i, j, k, l = params

    # Section de tri pour éviter de tester trop de valeurs.
    # D'autres valeurs impossibles sont traitées plus bas.
    if (i > 0 and j > v12 / v11 * i and j < - v12 / v11 * i + 4 * v12) or (i < 0 and j > - v12 / v11 * i and j < v12 / v11 * i + 4 * v12) or i == 0:
        if (k > 0 and l > v12 / v11 * k and l < - v12 / v11 * k + 4 * v12) or (k < 0 and l > - v12 / v11 * k and l < v12 / v11 * k + 4 * v12) or k == 0:
            if (((reflection(k, l, i, j)[0] > - v11) and (reflection(k, l, i, j)[0] < v11) and (reflection(k, l, i, j)[1] > 0) and (reflection(k, l, i, j)[1] < 4 * v12)) and ((reflection(k, l, i, j)[0] > 0 and reflection(k, l, i, j)[1] > v12 / v11 * reflection(k, l, i, j)[0] and reflection(k, l, i, j)[1] < - v12 / v11 * reflection(k, l, i, j)[0] + 4 * v12) or (reflection(k, l, i, j)[0] < 0 and reflection(k, l, i, j)[1] > - v12 / v11 * reflection(k, l, i, j)[0] and reflection(k, l, i, j)[1] < v12 / v11 * reflection(k, l, i, j)[0] + 4 * v12))) or reflection(k, l, i, j)[0] == 0:  
                while True:
                    programme = f'real aire = 6 * cos(pi / 14) * (1 + 2 * cos(pi / 7) * sin(pi /14));\n\n// Centre de symétrie n2\nreal sigma1 = {i};\nreal sigma2 = {j};\n\n// z\nreal gamma1 = {k};\nreal gamma2 = {l};\n\n// w\nreal zeta1 = {reflection(k, l, i, j)[0]};\nreal zeta2 = {reflection(k, l, i, j)[1]};\n\nint n = {precision};\nint nbrValeursPropres = {nbrVP};\n\nreal v11 = 1 + 2 * cos(pi / 7) - sin(pi / 14);\nreal v12 = cos(pi / 14);\n\nreal v21 = 0;\nreal v22 = 2 * cos(pi / 14);\n\nreal v31 = -1 - 2 * cos(pi / 7) + sin(pi / 14);\nreal v32 = cos(pi / 14);\n\n// z et w après rotation autour du centre\nreal gamma1R = {reflection(k, l, 0, 2 * v12)[0]};\nreal gamma2R = {reflection(k, l, 0, 2 * v12)[1]};\nreal zeta1R = {reflection(reflection(k, l, i, j)[0], reflection(k, l, i, j)[1], 0, 2 * v12)[0]};\nreal zeta2R = {reflection(reflection(k, l, i, j)[0], reflection(k, l, i, j)[1], 0, 2 * v12)[1]};' + '\n\nborder H1 (t = v31, 0) {x = t; y = v32 / v31 * t; label = 1;};\nborder H2 (t = v32, v32 + v22) {x = v31; y = t; label = 2;};\nborder H3 (t = 2, 2 + v11) {x = t; y = v12 / v11 * (t - 2); label = 3;};\nborder H4 (t = v32, v32 + v22) {x = 2 + v11; y = t; label = 4;};\n\nborder H5 (t = v31, 0) {x = t; y = v12 / v11 * t + v12 + v32 + v22; label = 5;};\nborder H6 (t = 2, 2 + v11) {x = t; y = v32 / v31 * (t - 2) + v12 + v32 + v22; label = 6;};\n\nborder H7 (t = v31, 0) {x = t; y = v32 / v31 * t + 8; label = 7;};\nborder H8 (t = 8 + v32, 8 + v32 + v22) {x = v31; y = t; label = 8;};\nborder H9 (t = 2, 2 + v11) {x = t; y = v12 / v11 * (t - 2) + 8; label = 9;};\nborder H10 (t = 8 + v32, 8 + v32 + v22) {x = 2 + v11; y = t; label = 10;};\n\nborder H11 (t = v31, 0) {x = t; y = v12 / v11 * t + v12 + v32 + v22 + 8; label = 11;};\nborder H12 (t = 2, 2 + v11) {x = t; y = v32 / v31 * (t - 2) + v12 + v32 + v22 + 8; label = 12;};\n\nif (zeta1 != gamma1)\n{\n    border H13 (t = gamma1, zeta1) {x = t; y = (zeta2 - gamma2) / (zeta1 - gamma1) * (t - gamma1) + gamma2; label = 13;};\n    border H14 (t = gamma1, 0) {x = t; y = (gamma2 > zeta2) * ((v12 + v32 + v22 - gamma2) / (- gamma1) * (t - gamma1) + gamma2) + (gamma2 < zeta2) * ( gamma2 / gamma1 * (t - gamma1) + gamma2); label = 14;};\n    border H15 (t = zeta1, 0) {x = t; y = (gamma2 < zeta2) * ((v12 + v32 + v22 - zeta2) / (- zeta1) * (t - zeta1) + zeta2) + (gamma2 > zeta2) * (zeta2 / zeta1 * (t - zeta1) + zeta2); label = 15;};\n\n    border H16 (t = 1 + gamma1R, 1 + zeta1R) {x = t; y = (zeta2R - gamma2R) / (zeta1R - gamma1R) * (t - 1 - gamma1R) + gamma2R; label = 16;};\n    border H17 (t = 1 + gamma1R, 1) {x = t; y = (gamma2R > zeta2R) * ((v12 + v32 + v22 - gamma2R) / (- gamma1R) * (t - 1 - gamma1R) + gamma2R) + (gamma2R < zeta2R) * ( gamma2R / gamma1R * (t - 1 - gamma1R) + gamma2R); label = 17;};\n    border H18 (t = 1 + zeta1R, 1) {x = t; y = (gamma2R < zeta2R) * ((v12 + v32 + v22 - zeta2R) / (- zeta1R) * (t - 1 - zeta1R) + zeta2R) + (gamma2R > zeta2R) * (zeta2R / zeta1R * (t - 1 - zeta1R) + zeta2R); label = 18;};\n\n    border H19 (t = 1 + gamma1, 1 + zeta1) {x = t; y = (zeta2 - gamma2) / (zeta1 - gamma1) * (t - 1 - gamma1) + gamma2; label = 19;};\n    border H20 (t = 1 + gamma1, 1) {x = t; y = (gamma2 > zeta2) * ((v12 + v32 + v22 - gamma2) / (- gamma1) * (t - 1 - gamma1) + gamma2) + (gamma2 < zeta2) * ( gamma2 / gamma1 * (t - 1 - gamma1) + gamma2); label = 20;};\n    border H21 (t = 1 + zeta1, 1) {x = t; y = (gamma2 < zeta2) * ((v12 + v32 + v22 - zeta2) / (- zeta1) * (t - 1 - zeta1) + zeta2) + (gamma2 > zeta2) * (zeta2 / zeta1 * (t - 1 - zeta1) + zeta2); label = 21;};\n\n    border H22 (t = 2 + gamma1R, 2 + zeta1R) {x = t; y = (zeta2R - gamma2R) / (zeta1R - gamma1R) * (t - 2 - gamma1R) + gamma2R; label = 22;};\n    border H23 (t = 2 + gamma1R, 2) {x = t; y = (gamma2R > zeta2R) * ((v12 + v32 + v22 - gamma2R) / (- gamma1R) * (t - 2 - gamma1R) + gamma2R) + (gamma2R < zeta2R) * ( gamma2R / gamma1R * (t - 2 - gamma1R) + gamma2R); label = 23;};\n    border H24 (t = 2 + zeta1R, 2) {x = t; y = (gamma2R < zeta2R) * ((v12 + v32 + v22 - zeta2R) / (- zeta1R) * (t - 2 - zeta1R) + zeta2R) + (gamma2R > zeta2R) * (zeta2R / zeta1R * (t - 2 - zeta1R) + zeta2R); label = 24;};\n\n    border H25 (t = gamma1, zeta1) {x = t; y = (zeta2 - gamma2) / (zeta1 - gamma1) * (t - gamma1) + gamma2 + 8; label = 25;};\n    border H26 (t = gamma1, 0) {x = t; y = (gamma2 > zeta2) * ((v12 + v32 + v22 - gamma2) / (- gamma1) * (t - gamma1) + gamma2) + (gamma2 < zeta2) * ( gamma2 / gamma1 * (t - gamma1) + gamma2) + 8; label = 26;};\n    border H27 (t = zeta1, 0) {x = t; y = (gamma2 < zeta2) * ((v12 + v32 + v22 - zeta2) / (- zeta1) * (t - zeta1) + zeta2) + (gamma2 > zeta2) * (zeta2 / zeta1 * (t - zeta1) + zeta2) + 8; label = 27;};\n\n    border H28 (t = 1 + gamma1R, 1 + zeta1R) {x = t; y = (zeta2R - gamma2R) / (zeta1R - gamma1R) * (t - 1 - gamma1R) + gamma2R + 8; label = 28;};\n    border H29 (t = 1 + gamma1R, 1) {x = t; y = (gamma2R > zeta2R) * ((v12 + v32 + v22 - gamma2R) / (- gamma1R) * (t - 1 - gamma1R) + gamma2R) + (gamma2R < zeta2R) * ( gamma2R / gamma1R * (t - 1 - gamma1R) + gamma2R) + 8; label = 29;};\n    border H30 (t = 1 + zeta1R, 1) {x = t; y = (gamma2R < zeta2R) * ((v12 + v32 + v22 - zeta2R) / (- zeta1R) * (t - 1 - zeta1R) + zeta2R) + (gamma2R > zeta2R) * (zeta2R / zeta1R * (t - 1 - zeta1R) + zeta2R) + 8; label = 30;};\n\n    border H31 (t = 1 + gamma1, 1 + zeta1) {x = t; y = (zeta2 - gamma2) / (zeta1 - gamma1) * (t - 1 - gamma1) + gamma2 + 8; label = 31;};\n    border H32 (t = 1 + gamma1, 1) {x = t; y = (gamma2 > zeta2) * ((v12 + v32 + v22 - gamma2) / (- gamma1) * (t - 1 - gamma1) + gamma2) + (gamma2 < zeta2) * ( gamma2 / gamma1 * (t - 1 - gamma1) + gamma2) + 8; label = 32;};\n    border H33 (t = 1 + zeta1, 1) {x = t; y = (gamma2 < zeta2) * ((v12 + v32 + v22 - zeta2) / (- zeta1) * (t - 1 - zeta1) + zeta2) + (gamma2 > zeta2) * (zeta2 / zeta1 * (t - 1 - zeta1) + zeta2) + 8; label = 33;};\n\n    border H34 (t = 2 + gamma1R, 2 + zeta1R) {x = t; y = (zeta2R - gamma2R) / (zeta1R - gamma1R) * (t - 2 - gamma1R) + gamma2R + 8; label = 34;};\n    border H35 (t = 2 + gamma1R, 2) {x = t; y = (gamma2R > zeta2R) * ((v12 + v32 + v22 - gamma2R) / (- gamma1R) * (t - 2 - gamma1R) + gamma2R) + (gamma2R < zeta2R) * ( gamma2R / gamma1R * (t - 2 - gamma1R) + gamma2R) + 8; label = 35;};\n    border H36 (t = 2 + zeta1R, 2) {x = t; y = (gamma2R < zeta2R) * ((v12 + v32 + v22 - zeta2R) / (- zeta1R) * (t - 2 - zeta1R) + zeta2R) + (gamma2R > zeta2R) * (zeta2R / zeta1R * (t - 2 - zeta1R) + zeta2R) + 8; label = 36;};\n\n    mesh Th = ' + f'buildmesh(H1({signeBords[0]}n) + H2({signeBords[1]}n) + H3({signeBords[2]}n) + H4({signeBords[3]}n) + H5({signeBords[4]}n) + H6({signeBords[5]}n) + H7({signeBords[6]}n) + H8({signeBords[7]}n) + H9({signeBords[8]}n) + H10({signeBords[9]}n) + H11({signeBords[10]}n) + H12({signeBords[11]}n) + H13({signeBords[12]}n) + H14({signeBords[13]}n) + H15({signeBords[14]}n) + H16({signeBords[15]}n) + H17({signeBords[16]}n) + H18({signeBords[17]}n) + H19({signeBords[18]}n) + H20({signeBords[19]}n) + H21({signeBords[20]}n) + H22({signeBords[21]}n) + H23({signeBords[22]}n) + H24({signeBords[23]}n) + H25({signeBords[24]}n) + H26({signeBords[25]}n) + H27({signeBords[26]}n) + H28({signeBords[27]}n) + H29({signeBords[28]}n) + H30({signeBords[29]}n) + H31({signeBords[30]}n) + H32({signeBords[31]}n) + H33({signeBords[32]}n) + H34({signeBords[33]}n) + H35({signeBords[34]}n) + H36({signeBords[35]}n), fixedborder = 1);' + '\n\n    fespace Vh(Th, P1, periodic = [[2, y], [4, y], [1, x + 2 + v11], [6, x], [3, x - 2 - v11], [5, x], [8, y], [10, y],\n                                    [7, x + 2 + v11], [12, x], [9, x - 2 - v11], [11, x], [13, 8 + y], [31, y], [25, y], [19, y + 8],\n                                    [16, y + 8], [34, y], [22, y + 8], [28, y], [14, y], [20, y], [15, y], [21, y], [24, y], [18, y],\n                                    [23, y], [17, y], [26, y], [32, y], [27, y], [33, y], [29, y], [35, y], [30, y], [36, y]]);\n\n    Vh u1, u2;\n    real sigma = 0.00001;\n\n    varf op (u1, u2) = int2d(Th)(dx(u1) * dx(u2) + dy(u1) * dy(u2) - sigma * u1 * u2);\n    varf bm ([u1], [u2]) = int2d(Th)(u1 * u2);\n\n    matrix OP = op(Vh, Vh, solver = Crout, factorize = 1);\n    matrix B = bm(Vh, Vh, solver = CG, eps = 1e-20);\n\n    real[int] ev(nbrValeursPropres);\n    Vh[int] eV(nbrValeursPropres);\n\n    int k = EigenValue(OP, B, sym = true, sigma = sigma, value = ev, vector = eV, tol=1e-10, maxit = 0, ncv = 0);\n\n    for (int i = 0; i < k; i++)\n    {\n        u1 = eV[i];\n\n        cout << "lambda[" << i << "] = " << ev[i] << ", normalisation : " << ev[i] * (2 * aire) << ", err = " << int2d(Th)(dx(u1) * dx(u1) + dy(u1) * dy(u1) - (ev[i]) * u1 * u1) << endl;\n    }\n}\n\nelse\n{\n    border H13 (t = gamma2, zeta2) {x = gamma1; y = t; label = 13;};\n    border H14 (t = gamma1, 0) {x = t; y = (gamma2 > zeta2) * ((v12 + v32 + v22 - gamma2) / (- gamma1) * (t - gamma1) + gamma2) + (gamma2 < zeta2) * ( gamma2 / gamma1 * (t - gamma1) + gamma2); label = 14;};\n    border H15 (t = zeta1, 0) {x = t; y = (gamma2 < zeta2) * ((v12 + v32 + v22 - zeta2) / (- zeta1) * (t - zeta1) + zeta2) + (gamma2 > zeta2) * (zeta2 / zeta1 * (t - zeta1) + zeta2); label = 15;};\n\n    border H16 (t = gamma2R, zeta2R) {x = 1 + zeta1R; y = t; label = 16;};\n    border H17 (t = 1 + gamma1R, 1) {x = t; y = (gamma2R > zeta2R) * ((v12 + v32 + v22 - gamma2R) / (- gamma1R) * (t - 1 - gamma1R) + gamma2R) + (gamma2R < zeta2R) * ( gamma2R / gamma1R * (t - 1 - gamma1R) + gamma2R); label = 17;};\n    border H18 (t = 1 + zeta1R, 1) {x = t; y = (gamma2R < zeta2R) * ((v12 + v32 + v22 - zeta2R) / (- zeta1R) * (t - 1 - zeta1R) + zeta2R) + (gamma2R > zeta2R) * (zeta2R / zeta1R * (t - 1 - zeta1R) + zeta2R); label = 18;};\n\n    border H19 (t = gamma2, zeta2) {x = 1 + gamma1; y = t; label = 19;};\n    border H20 (t = 1 + gamma1, 1) {x = t; y = (gamma2 > zeta2) * ((v12 + v32 + v22 - gamma2) / (- gamma1) * (t - 1 - gamma1) + gamma2) + (gamma2 < zeta2) * ( gamma2 / gamma1 * (t - 1 - gamma1) + gamma2); label = 20;};\n    border H21 (t = 1 + zeta1, 1) {x = t; y = (gamma2 < zeta2) * ((v12 + v32 + v22 - zeta2) / (- zeta1) * (t - 1 - zeta1) + zeta2) + (gamma2 > zeta2) * (zeta2 / zeta1 * (t - 1 - zeta1) + zeta2); label = 21;};\n\n    border H22 (t = gamma2R, zeta2R) {x = 2 + zeta1R; y = t; label = 22;};\n    border H23 (t = 2 + gamma1R, 2) {x = t; y = (gamma2R > zeta2R) * ((v12 + v32 + v22 - gamma2R) / (- gamma1R) * (t - 2 - gamma1R) + gamma2R) + (gamma2R < zeta2R) * ( gamma2R / gamma1R * (t - 2 - gamma1R) + gamma2R); label = 23;};\n    border H24 (t = 2 + zeta1R, 2) {x = t; y = (gamma2R < zeta2R) * ((v12 + v32 + v22 - zeta2R) / (- zeta1R) * (t - 2 - zeta1R) + zeta2R) + (gamma2R > zeta2R) * (zeta2R / zeta1R * (t - 2 - zeta1R) + zeta2R); label = 24;};\n\n    border H25 (t = gamma2, zeta2) {x = gamma1; y = t + 8; label = 25;};\n    border H26 (t = gamma1, 0) {x = t; y = (gamma2 > zeta2) * ((v12 + v32 + v22 - gamma2) / (- gamma1) * (t - gamma1) + gamma2) + (gamma2 < zeta2) * ( gamma2 / gamma1 * (t - gamma1) + gamma2) + 8; label = 26;};\n    border H27 (t = zeta1, 0) {x = t; y = (gamma2 < zeta2) * ((v12 + v32 + v22 - zeta2) / (- zeta1) * (t - zeta1) + zeta2) + (gamma2 > zeta2) * (zeta2 / zeta1 * (t - zeta1) + zeta2) + 8; label = 27;};\n\n    border H28 (t = gamma2R, zeta2R) {x = 1 + zeta1R; y = t + 8; label = 28;};\n    border H29 (t = 1 + gamma1R, 1) {x = t; y = (gamma2R > zeta2R) * ((v12 + v32 + v22 - gamma2R) / (- gamma1R) * (t - 1 - gamma1R) + gamma2R) + (gamma2R < zeta2R) * ( gamma2R / gamma1R * (t - 1 - gamma1R) + gamma2R) + 8; label = 29;};\n    border H30 (t = 1 + zeta1R, 1) {x = t; y = (gamma2R < zeta2R) * ((v12 + v32 + v22 - zeta2R) / (- zeta1R) * (t - 1 - zeta1R) + zeta2R) + (gamma2R > zeta2R) * (zeta2R / zeta1R * (t - 1 - zeta1R) + zeta2R) + 8; label = 30;};\n\n    border H31 (t = gamma2, zeta2) {x = 1 + gamma1; y = t + 8; label = 31;};\n    border H32 (t = 1 + gamma1, 1) {x = t; y = (gamma2 > zeta2) * ((v12 + v32 + v22 - gamma2) / (- gamma1) * (t - 1 - gamma1) + gamma2) + (gamma2 < zeta2) * ( gamma2 / gamma1 * (t - 1 - gamma1) + gamma2) + 8; label = 32;};\n    border H33 (t = 1 + zeta1, 1) {x = t; y = (gamma2 < zeta2) * ((v12 + v32 + v22 - zeta2) / (- zeta1) * (t - 1 - zeta1) + zeta2) + (gamma2 > zeta2) * (zeta2 / zeta1 * (t - 1 - zeta1) + zeta2) + 8; label = 33;};\n\n    border H34 (t = gamma2R, zeta2R) {x = 2 + zeta1R; y = t + 8; label = 34;};\n    border H35 (t = 2 + gamma1R, 2) {x = t; y = (gamma2R > zeta2R) * ((v12 + v32 + v22 - gamma2R) / (- gamma1R) * (t - 2 - gamma1R) + gamma2R) + (gamma2R < zeta2R) * ( gamma2R / gamma1R * (t - 2 - gamma1R) + gamma2R) + 8; label = 35;};\n    border H36 (t = 2 + zeta1R, 2) {x = t; y = (gamma2R < zeta2R) * ((v12 + v32 + v22 - zeta2R) / (- zeta1R) * (t - 2 - zeta1R) + zeta2R) + (gamma2R > zeta2R) * (zeta2R / zeta1R * (t - 2 - zeta1R) + zeta2R) + 8; label = 36;};\n\n    //plot(H1(n) + H2(n) + H3(n) + H4(n) + H5(n) + H6(n) + H7(n) + H8(n) + H9(n) + H10(n) + H11(n) + H12(n) + H13(n) + H14(n) + H15(n) + H16(n) + H17(n) + H18(n) + H19(n) + H20(n) + H21(n) + H22(n) + H23(n) + H24(n) + H25(n) + H26(n) + H27(n) + H28(n) + H29(n) + H30(n) + H31(n) + H32(n) + H33(n) + H34(n) + H35(n) + H36(n));\n\n    mesh Th = ' + f'buildmesh(H1({signeBords[0]}n) + H2({signeBords[1]}n) + H3({signeBords[2]}n) + H4({signeBords[3]}n) + H5({signeBords[4]}n) + H6({signeBords[5]}n) + H7({signeBords[6]}n) + H8({signeBords[7]}n) + H9({signeBords[8]}n) + H10({signeBords[9]}n) + H11({signeBords[10]}n) + H12({signeBords[11]}n) + H13({signeBords[12]}n) + H14({signeBords[13]}n) + H15({signeBords[14]}n) + H16({signeBords[15]}n) + H17({signeBords[16]}n) + H18({signeBords[17]}n) + H19({signeBords[18]}n) + H20({signeBords[19]}n) + H21({signeBords[20]}n) + H22({signeBords[21]}n) + H23({signeBords[22]}n) + H24({signeBords[23]}n) + H25({signeBords[24]}n) + H26({signeBords[25]}n) + H27({signeBords[26]}n) + H28({signeBords[27]}n) + H29({signeBords[28]}n) + H30({signeBords[29]}n) + H31({signeBords[30]}n) + H32({signeBords[31]}n) + H33({signeBords[32]}n) + H34({signeBords[33]}n) + H35({signeBords[34]}n) + H36({signeBords[35]}n), fixedborder = 1);' + '\n\n    fespace Vh(Th, P1, periodic = [[2, y], [4, y], [1, x + 2 + v11], [6, x], [3, x - 2 - v11], [5, x], [8, y], [10, y],\n                                    [7, x + 2 + v11], [12, x], [9, x - 2 - v11], [11, x], [13, 8 + y], [31, y], [25, y], [19, y + 8],\n                                    [16, y + 8], [34, y], [22, y + 8], [28, y], [14, y], [20, y], [15, y], [21, y], [24, y], [18, y],\n                                    [23, y], [17, y], [26, y], [32, y], [27, y], [33, y], [29, y], [35, y], [30, y], [36, y]]);\n\n    Vh u1, u2;\n    real sigma = 0.00001;\n\n    varf op (u1, u2) = int2d(Th)(dx(u1) * dx(u2) + dy(u1) * dy(u2) - sigma * u1 * u2);\n    varf bm ([u1], [u2]) = int2d(Th)(u1 * u2);\n\n    matrix OP = op(Vh, Vh, solver = Crout, factorize = 1);\n    matrix B = bm(Vh, Vh, solver = CG, eps = 1e-20);\n\n    real[int] ev(nbrValeursPropres);\n    Vh[int] eV(nbrValeursPropres);\n\n    int k = EigenValue(OP, B, sym = true, sigma = sigma, value = ev, vector = eV, tol=1e-10, maxit = 0, ncv = 0);\n\n    for (int i = 0; i < k; i++)\n    {\n        u1 = eV[i];\n\n        cout << "lambda[" << i << "] = " << ev[i] << ", normalisation : " << ev[i] * (2 * aire) << ", err = " << int2d(Th)(dx(u1) * dx(u1) + dy(u1) * dy(u1) - (ev[i]) * u1 * u1) << endl;\n    }\n}'
                    fichier = open(f"{chemin}{nom}.edp", "w")
                    fichier.write(programme)
                    fichier.close()

                    if cheminFF != "":
                        texte = os.popen(f"{cheminFF} {chemin}{nom}.edp").read()
                    else:
                        texte = os.popen(f"{chemin}{nom}.edp").read()

                    if len(texte.split("Error in the definition of subdomain ")) == 1 or bugDeSigne == 2:
                        break

                    else:
                        positionsChangements = []
                        bugDeSigne += 1

                        for pos in range(1, len(texte.split("Error in the definition of subdomain "))):
                            positionsChangements.append(int(texte.split("Error in the definition of subdomain ")[pos].split("/")[0].split("border ")[1]) - 1)

                        for pos in positionsChangements:
                            signeBords[pos] = (signeBords[pos] == "-") * "" + (signeBords[pos] == "") * "-"

                # Autre zone de tri. On renvoie 0 pour influencer le solveur.               
                if len(texte.split("tau1 trop proche de sigma1")) == 3 or len(texte.split("Some giving point are outside the domain")) != 1 or len(texte.split("The boundary is crossing maybe!")) != 1 or bugDeSigne == 2 or len(texte.split("Number of Negative triangles")) != 1 or len(texte.split("normalisation : ")) < 5:
                    return 0

                return - float(texte.split("normalisation : ")[4].split(",")[0])
                
    return 0

for i in range(50):
    res = minimize(valeurPropre, [random.random(), random.random(), random.random(), random.random()], method = 'nelder-mead', options={'xatol': 1e-6, 'disp': False})

    val = abs(valeurPropre(list(res.x)))

    if (val > 0):
        print(f"Test #{i} :")
        print(f"{val} : {list(res.x)}")
###########################################################